7,8c7,8
< //  \brief derived class for time integrator task list. Can create task lists for one
< //  of many different time integrators (e.g. van Leer, RK2, RK3, etc.)
---
> //! \brief derived class for time integrator task list. Can create task lists for one
> //! of many different time integrators (e.g. van Leer, RK2, RK3, etc.)
28a29
> #include "../orbital_advection/orbital_advection.hpp"
32,37d32
< #include "../diagnostics/diagnostics.hpp"
< #include "../physics/physics.hpp"
< #include "../particles/particles.hpp"
< #include "../particles/particle_buffer.hpp"
< #include "../turbulence/turbulence_model.hpp"
< //#include "../debugger/debugger.hpp"
41c36
< //  TimeIntegratorTaskList constructor
---
> //! TimeIntegratorTaskList constructor
44,71c39,75
<   // First, define each time-integrator by setting weights for each step of the algorithm
<   // and the CFL number stability limit when coupled to the single-stage spatial operator.
<   // Currently, the explicit, multistage time-integrators must be expressed as 2S-type
<   // algorithms as in Ketcheson (2010) Algorithm 3, which incudes 2N (Williamson) and 2R
<   // (van der Houwen) popular 2-register low-storage RK methods. The 2S-type integrators
<   // depend on a bidiagonally sparse Shu-Osher representation; at each stage l:
<   //
<   //    U^{l} = a_{l,l-2}*U^{l-2} + a_{l-1}*U^{l-1}
<   //          + b_{l,l-2}*dt*Div(F_{l-2}) + b_{l,l-1}*dt*Div(F_{l-1}),
<   //
<   // where U^{l-1} and U^{l-2} are previous stages and a_{l,l-2}, a_{l,l-1}=(1-a_{l,l-2}),
<   // and b_{l,l-2}, b_{l,l-1} are weights that are different for each stage and
<   // integrator. Previous timestep U^{0} = U^n is given, and the integrator solves
<   // for U^{l} for 1 <= l <= nstages.
<   //
<   // The 2x RHS evaluations of Div(F) and source terms per stage is avoided by adding
<   // another weighted average / caching of these terms each stage. The API and framework
<   // is extensible to three register 3S* methods, although none are currently implemented.
<
<   // Notation: exclusively using "stage", equivalent in lit. to "substage" or "substep"
<   // (infrequently "step"), to refer to the intermediate values of U^{l} between each
<   // "timestep" = "cycle" in explicit, multistage methods. This is to disambiguate the
<   // temporal integration from other iterative sequences; "Step" is often used for generic
<   // sequences in code, e.g. main.cpp: "Step 1: MPI"
<   //
<   // main.cpp invokes the tasklist in a for () loop from stage=1 to stage=ptlist->nstages
<
<   // TODO(felker): validate Field and Hydro diffusion with RK3, RK4, SSPRK(5,4)
---
>   //! \note
>   //! First, define each time-integrator by setting weights for each step of
>   //! the algorithm and the CFL number stability limit when coupled to the single-stage
>   //! spatial operator.
>   //! Currently, the explicit, multistage time-integrators must be expressed as 2S-type
>   //! algorithms as in Ketcheson (2010) Algorithm 3, which incudes 2N (Williamson) and 2R
>   //! (van der Houwen) popular 2-register low-storage RK methods. The 2S-type integrators
>   //! depend on a bidiagonally sparse Shu-Osher representation; at each stage l:
>   //! \f[
>   //!   U^{l} = a_{l,l-2}*U^{l-2} + a_{l-1}*U^{l-1}
>   //!         + b_{l,l-2}*dt*Div(F_{l-2}) + b_{l,l-1}*dt*Div(F_{l-1}),
>   //! \f]
>   //! where \f$U^{l-1}\f$ and \f$U^{l-2}\f$ are previous stages and
>   //! \f$a_{l,l-2}\f$, \f$a_{l,l-1}=(1-a_{l,l-2})\f$,
>   //! and \f$b_{l,l-2}\f$, \f$b_{l,l-1}\f$
>   //! are weights that are different for each stage and
>   //! integrator. Previous timestep \f$U^{0} = U^n\f$ is given, and the integrator solves
>   //! for \f$U^{l}\f$ for 1 <= l <= nstages.
>   //!
>   //! \note
>   //! The 2x RHS evaluations of Div(F) and source terms per stage is avoided by adding
>   //! another weighted average / caching of these terms each stage. The API and framework
>   //! is extensible to three register 3S* methods,
>   //! although none are currently implemented.
>   //!
>   //! \note
>   //! Notation: exclusively using "stage", equivalent in lit. to "substage" or "substep"
>   //! (infrequently "step"), to refer to the intermediate values of U^{l} between each
>   //! "timestep" = "cycle" in explicit, multistage methods. This is to disambiguate the
>   //! temporal integration from other iterative sequences;  generic
>   //! "Step" is often used for sequences in code, e.g. main.cpp: "Step 1: MPI"
>   //!
>   //! \note
>   //! main.cpp invokes the tasklist in a for () loop from stage=1 to stage=ptlist->nstages
>   //!
>   //! \todo (felker):
>   //! - validate Field and Hydro diffusion with RK3, RK4, SSPRK(5,4)
73a78,103
>   // Read a flag for orbital advection
>   ORBITAL_ADVECTION = (pm->orbital_advection != 0)? true : false;
>
>   // Read a flag for shear periodic
>   SHEAR_PERIODIC = pm->shear_periodic;
>
>   if (integrator == "rk4" || integrator == "ssprk5_4") {
>     // shear periodic not work with rk4 or ssprk5_4
>     if (SHEAR_PERIODIC) {
>       std::stringstream msg;
>       msg << "### FATAL ERROR in TimeIntegratorTaskList constructor" << std::endl
>           << "integrator=" << integrator << " does not work with shear periodic boundary."
>           << std::endl;
>       ATHENA_ERROR(msg);
>     }
>     // orbital advection + mesh refinement not work with rk4 or ssprk5_4
>     if (ORBITAL_ADVECTION && pm->multilevel) {
>       std::stringstream msg;
>       msg << "### FATAL ERROR in TimeIntegratorTaskList constructor" << std::endl
>           << "integrator=" << integrator << " does not work with orbital advection and "
>           << "mesh refinement"
>           << std::endl;
>       ATHENA_ERROR(msg);
>     }
>   }
>
75,79c105,212
<     // VL: second-order van Leer integrator (Stone & Gardiner, NewA 14, 139 2009)
<     // Simple predictor-corrector scheme similar to MUSCL-Hancock
<     // Expressed in 2S or 3S* algorithm form
<     nstages = 2;
<     cfl_limit = 20.0;
---
>     //! \note `integrator == "vl2"`
>     //! - VL: second-order van Leer integrator (Stone & Gardiner, NewA 14, 139 2009)
>     //! - Simple predictor-corrector scheme similar to MUSCL-Hancock
>     //! - Expressed in 2S or 3S* algorithm form
>
>     // set number of stages and time coeff.
>     nstages_main = 2;
>     if (ORBITAL_ADVECTION) {
>       // w/ orbital advection
>       if (SHEAR_PERIODIC || pm->multilevel) {
>         // w/ shear_periodic or refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 0.5;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.0;
>         } else { // second order splitting
>           nstages = nstages_main+2;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 0.5;
>           stage_wghts[2].beta = 1.0;
>           stage_wghts[3].beta = 0.0;
>         }
>       } else { // w/o shear periodic and refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main;
>           for (int l=0; l<nstages; l++) {
>             stage_wghts[l].main_stage = true;
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 0.5;
>           stage_wghts[1].beta = 1.0;
>         } else { // second order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 0.5;
>           stage_wghts[2].beta = 1.0;
>         }
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       for (int l=0; l<nstages; l++) {
>         stage_wghts[l].main_stage = true;
>         stage_wghts[l].orbital_stage = false;
>       }
>       stage_wghts[0].sbeta = 0.0;
>       stage_wghts[0].ebeta = 0.5;
>       stage_wghts[1].sbeta = 0.5;
>       stage_wghts[1].ebeta = 1.0;
>       stage_wghts[0].beta = 0.5;
>       stage_wghts[1].beta = 1.0;
>     }
>     cfl_limit = 1.0;
81,82c214,215
<     //if (pm->ndim == 2) cfl_limit = 0.5;
<     //if (pm->ndim == 3) cfl_limit = 0.5;
---
>     if (pm->ndim == 2) cfl_limit = 0.5;
>     if (pm->ndim == 3) cfl_limit = 0.5;
84,94c217,235
<     stage_wghts[0].delta = 1.0; // required for consistency
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 0.5;
<
<     stage_wghts[1].delta = 0.0;
<     stage_wghts[1].gamma_1 = 0.0;
<     stage_wghts[1].gamma_2 = 1.0;
<     stage_wghts[1].gamma_3 = 0.0;
<     stage_wghts[1].beta = 1.0;
---
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0; // required for consistency
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 1) {
>           stage_wghts[n].delta = 0.0;
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         }
>       }
>     }
96,97c237,315
<     // RK1: first-order Runge-Kutta / the forward Euler (FE) method
<     nstages = 1;
---
>     //! \note `integrator == "rk1"`
>     //! - RK1: first-order Runge-Kutta / the forward Euler (FE) method
>
>     // set number of stages and time coeff.
>     nstages_main = 1;
>     if (ORBITAL_ADVECTION) {
>       // w/ orbital advection
>       if (SHEAR_PERIODIC || pm->multilevel) {
>         // w/ shear_periodic or refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 1.0;
>           stage_wghts[1].beta = 0.0;
>         } else { // second order splitting
>           nstages = nstages_main+2;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.0;
>         }
>       } else { // w/o shear periodic and refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main;
>           stage_wghts[0].main_stage = true;
>           stage_wghts[0].orbital_stage = true;
>           stage_wghts[0].sbeta = 0.0;
>           stage_wghts[0].ebeta = 1.0;
>           stage_wghts[0].beta = 1.0;
>         } else { // second order splitting
>           nstages = nstages_main+1;
>           stage_wghts[0].main_stage = false;
>           stage_wghts[1].main_stage = true;
>           stage_wghts[0].orbital_stage = true;
>           stage_wghts[1].orbital_stage = true;
>           stage_wghts[0].sbeta = 0.0;
>           stage_wghts[0].ebeta = 0.5;
>           stage_wghts[1].sbeta = 0.5;
>           stage_wghts[1].ebeta = 1.0;
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>         }
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       stage_wghts[0].main_stage = true;
>       stage_wghts[0].orbital_stage = false;
>       stage_wghts[0].sbeta = 0.0;
>       stage_wghts[0].ebeta = 1.0;
>       stage_wghts[0].beta = 1.0;
>     }
99,103c317,330
<     stage_wghts[0].delta = 1.0;
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 1.0;
---
>
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0;
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         }
>       }
>     }
105,119c332,458
<     // Heun's method / SSPRK (2,2): Gottlieb (2009) equation 3.1
<     // Optimal (in error bounds) explicit two-stage, second-order SSPRK
<     nstages = 2;
<     cfl_limit = 20.;  // c_eff = c/nstages = 1/2 (Gottlieb (2009), pg 271)
<     stage_wghts[0].delta = 1.0;
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 1.0;
<
<     stage_wghts[1].delta = 0.0;
<     stage_wghts[1].gamma_1 = 0.5;
<     stage_wghts[1].gamma_2 = 0.5;
<     stage_wghts[1].gamma_3 = 0.0;
<     stage_wghts[1].beta = 0.5;
---
>     //! \note `integrator == "rk2"`
>     //! - Heun's method / SSPRK (2,2): Gottlieb (2009) equation 3.1
>     //! - Optimal (in error bounds) explicit two-stage, second-order SSPRK
>
>     // set number of stages and time coeff.
>     nstages_main = 2;
>     if (ORBITAL_ADVECTION) {
>       // w/ orbital advection
>       if (SHEAR_PERIODIC || pm->multilevel) {
>         // w/ shear_periodic or refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 1.0;
>           stage_wghts[1].beta = 0.5;
>           stage_wghts[2].beta = 0.0;
>         } else { // second order splitting
>           nstages = nstages_main+2;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.5;
>           stage_wghts[3].beta = 0.0;
>         }
>       } else { // w/o shear periodic and refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main;
>           for (int l=0; l<nstages; l++) {
>             stage_wghts[l].main_stage = true;
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 1.0;
>           stage_wghts[1].beta = 0.5;
>         } else { // second order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.5;
>         }
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       for (int l=0; l<nstages; l++) {
>         stage_wghts[l].main_stage = true;
>         stage_wghts[l].orbital_stage = false;
>       }
>       stage_wghts[0].sbeta = 0.0;
>       stage_wghts[0].ebeta = 1.0;
>       stage_wghts[1].sbeta = 1.0;
>       stage_wghts[1].ebeta = 1.0;
>       stage_wghts[0].beta = 1.0;
>       stage_wghts[1].beta = 0.5;
>     }
>     cfl_limit = 1.0;  // c_eff = c/nstages = 1/2 (Gottlieb (2009), pg 271)
>
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0;
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 1) {
>           stage_wghts[n].delta = 0.0;
>           stage_wghts[n].gamma_1 = 0.5;
>           stage_wghts[n].gamma_2 = 0.5;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         }
>       }
>     }
121,143c460,599
<     // SSPRK (3,3): Gottlieb (2009) equation 3.2
<     // Optimal (in error bounds) explicit three-stage, third-order SSPRK
<     nstages = 3;
<     cfl_limit = 20.;  // implicit scheme allows larger cfl limit
<     stage_wghts[0].delta = 1.0;
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 1.0;
<
<     stage_wghts[1].delta = 0.0;
<     stage_wghts[1].gamma_1 = 0.25;
<     stage_wghts[1].gamma_2 = 0.75;
<     stage_wghts[1].gamma_3 = 0.0;
<     stage_wghts[1].beta = 0.25;
<
<     stage_wghts[2].delta = 0.0;
<     stage_wghts[2].gamma_1 = TWO_3RD;
<     stage_wghts[2].gamma_2 = ONE_3RD;
<     stage_wghts[2].gamma_3 = 0.0;
<     stage_wghts[2].beta = TWO_3RD;
<     //} else if (integrator == "ssprk5_3") {
<     //} else if (integrator == "ssprk10_4") {
---
>     //! \note `integrator == "rk3"`
>     //! - SSPRK (3,3): Gottlieb (2009) equation 3.2
>     //! - Optimal (in error bounds) explicit three-stage, third-order SSPRK
>
>     // set number of stages and time coeff.
>     nstages_main = 3;
>     if (ORBITAL_ADVECTION) {
>       // w/ orbital advection
>       if (SHEAR_PERIODIC || pm->multilevel) {
>         // w/ shear_periodic or refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 1.0;
>           stage_wghts[1].beta = 0.25;
>           stage_wghts[2].beta = TWO_3RD;
>           stage_wghts[3].beta = 0.0;
>         } else { // second order splitting
>           nstages = nstages_main+2;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.25;
>           stage_wghts[3].beta = TWO_3RD;
>           stage_wghts[4].beta = 0.0;
>         }
>       } else { // w/o shear periodic and refinements
>         if (pm->orbital_advection==1) { // first order splitting
>           nstages = nstages_main;
>           for (int l=0; l<nstages; l++) {
>             stage_wghts[l].main_stage = true;
>             if (l == nstages-1) { // last stage
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].ebeta = 0.0;
>             }
>             stage_wghts[l].sbeta = 0.0;
>           }
>           stage_wghts[0].beta = 1.0;
>           stage_wghts[1].beta = 0.25;
>           stage_wghts[2].beta = TWO_3RD;
>         } else { // second order splitting
>           nstages = nstages_main+1;
>           for (int l=0; l<nstages; l++) {
>             if (l == 0) { // first stage
>               stage_wghts[l].main_stage = false;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.0;
>             } else if (l == nstages-1) { // last stage
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = true;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>               stage_wghts[l].ebeta = 1.0;
>             } else {
>               stage_wghts[l].main_stage = true;
>               stage_wghts[l].orbital_stage = false;
>               stage_wghts[l].sbeta = 0.5;
>               stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             }
>           }
>           stage_wghts[0].beta = 0.0;
>           stage_wghts[1].beta = 1.0;
>           stage_wghts[2].beta = 0.25;
>           stage_wghts[3].beta = TWO_3RD;
>         }
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       for (int l=0; l<nstages; l++) {
>         stage_wghts[l].main_stage = true;
>         stage_wghts[l].orbital_stage = false;
>       }
>       stage_wghts[0].sbeta = 0.0;
>       stage_wghts[0].ebeta = 1.0;
>       stage_wghts[1].sbeta = 1.0;
>       stage_wghts[1].ebeta = 0.5;
>       stage_wghts[2].sbeta = 0.5;
>       stage_wghts[2].ebeta = 1.0;
>       stage_wghts[0].beta = 1.0;
>       stage_wghts[1].beta = 0.25;
>       stage_wghts[2].beta = TWO_3RD;
>     }
>     cfl_limit = 1.0;  // c_eff = c/nstages = 1/3 (Gottlieb (2009), pg 271)
>
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0;
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 1) {
>           stage_wghts[n].delta = 0.0;
>           stage_wghts[n].gamma_1 = 0.25;
>           stage_wghts[n].gamma_2 = 0.75;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 2) {
>           stage_wghts[n].delta = 0.0;
>           stage_wghts[n].gamma_1 = TWO_3RD;
>           stage_wghts[n].gamma_2 = ONE_3RD;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         }
>       }
>     }
145,150c601,608
<     // RK4()4[2S] from Table 2 of Ketcheson (2010)
<     // Non-SSP, explicit four-stage, fourth-order RK
<     nstages = 4;
<     // Stability properties are similar to classical (non-SSP) RK4 (but ~2x L2 principal
<     // error norm). Refer to Colella (2011) for linear stability analysis of constant
<     // coeff. advection of classical RK4 + 4th or 1st order (limiter engaged) fluxes
---
>     //! \note `integorator == "rk4"`
>     //! - RK4()4[2S] from Table 2 of Ketcheson (2010)
>     //! - Non-SSP, explicit four-stage, fourth-order RK
>     //! - Stability properties are similar to classical (non-SSP) RK4
>     //!   (but ~2x L2 principal error norm).
>     //! - Refer to Colella (2011) for linear stability analysis of constant
>     //!   coeff. advection of classical RK4 + 4th or 1st order (limiter engaged) fluxes
>     nstages_main = 4;
152,174c610,729
<     stage_wghts[0].delta = 1.0;
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 1.193743905974738;
<
<     stage_wghts[1].delta = 0.217683334308543;
<     stage_wghts[1].gamma_1 = 0.121098479554482;
<     stage_wghts[1].gamma_2 = 0.721781678111411;
<     stage_wghts[1].gamma_3 = 0.0;
<     stage_wghts[1].beta = 0.099279895495783;
<
<     stage_wghts[2].delta = 1.065841341361089;
<     stage_wghts[2].gamma_1 = -3.843833699660025;
<     stage_wghts[2].gamma_2 = 2.121209265338722;
<     stage_wghts[2].gamma_3 = 0.0;
<     stage_wghts[2].beta = 1.131678018054042;
<
<     stage_wghts[3].delta = 0.0;
<     stage_wghts[3].gamma_1 = 0.546370891121863;
<     stage_wghts[3].gamma_2 = 0.198653035682705;
<     stage_wghts[3].gamma_3 = 0.0;
<     stage_wghts[3].beta = 0.310665766509336;
---
>
>     if (ORBITAL_ADVECTION) {
>       if (pm->orbital_advection==1) { // first order splitting
>         nstages = nstages_main;
>         for (int l=0; l<nstages; l++) {
>           stage_wghts[l].main_stage = true;
>           if (l == nstages-1) { // last stage
>             stage_wghts[l].orbital_stage = true;
>           } else {
>             stage_wghts[l].orbital_stage = false;
>           }
>         }
>         stage_wghts[0].beta = 1.193743905974738;
>         stage_wghts[1].beta = 0.099279895495783;
>         stage_wghts[2].beta = 1.131678018054042;
>         stage_wghts[3].beta = 0.310665766509336;
>       } else { // second order splitting
>         nstages = nstages_main+1;
>         for (int l=0; l<nstages; l++) {
>           if (l == 0) { // first stage
>             stage_wghts[l].main_stage = false;
>             stage_wghts[l].orbital_stage = true;
>           } else if (l == nstages-1) { // last stage
>             stage_wghts[l].main_stage = true;
>             stage_wghts[l].orbital_stage = true;
>           } else {
>             stage_wghts[l].main_stage = true;
>             stage_wghts[l].orbital_stage = false;
>           }
>         }
>         stage_wghts[0].beta = 0.0;
>         stage_wghts[1].beta = 1.193743905974738;
>         stage_wghts[2].beta = 0.099279895495783;
>         stage_wghts[3].beta = 1.131678018054042;
>         stage_wghts[4].beta = 0.310665766509336;
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       for (int l=0; l<nstages; l++) {
>         stage_wghts[l].main_stage = true;
>         stage_wghts[l].orbital_stage = false;
>       }
>       stage_wghts[0].beta = 1.193743905974738;
>       stage_wghts[1].beta = 0.099279895495783;
>       stage_wghts[2].beta = 1.131678018054042;
>       stage_wghts[3].beta = 0.310665766509336;
>     }
>
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0;
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 1) {
>           stage_wghts[n].delta = 0.217683334308543;
>           stage_wghts[n].gamma_1 = 0.121098479554482;
>           stage_wghts[n].gamma_2 = 0.721781678111411;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 2) {
>           stage_wghts[n].delta = 1.065841341361089;
>           stage_wghts[n].gamma_1 = -3.843833699660025;
>           stage_wghts[n].gamma_2 = 2.121209265338722;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 3) {
>           stage_wghts[n].delta = 0.0;
>           stage_wghts[n].gamma_1 = 0.546370891121863;
>           stage_wghts[n].gamma_2 = 0.198653035682705;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         }
>       }
>     }
>
>     // set sbeta & ebeta
>     if (ORBITAL_ADVECTION) {
>       if (pm->orbital_advection==1) { // first order splitting
>         for (int l=0; l<nstages; l++) {
>           if (l == nstages-1) { // last stage
>             stage_wghts[l].ebeta = 1.0;
>           } else {
>             stage_wghts[l].ebeta = 0.0;
>           }
>           stage_wghts[l].sbeta = 0.0;
>         }
>       } else { // second order splitting
>         for (int l=0; l<nstages; l++) {
>           if (l == 0) { // first stage
>             stage_wghts[l].sbeta = 0.0;
>           } else if (l == nstages-1) { // last stage
>             stage_wghts[l].sbeta = 0.5;
>             stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             stage_wghts[l].ebeta = 1.0;
>           } else {
>             stage_wghts[l].sbeta = 0.5;
>             stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>           }
>         }
>       }
>     } else { // w/o orbital advection ///
>       Real temp = 0.0;
>       Real temp_prev = 0.0;
>       stage_wghts[0].sbeta = 0.0;
>       for (int l=0; l<nstages-1; l++) {
>         temp_prev = temp;
>         temp = temp_prev + stage_wghts[l].delta*stage_wghts[l].sbeta;
>         stage_wghts[l].ebeta = stage_wghts[l].gamma_1*temp_prev
>                                + stage_wghts[l].gamma_2*temp
>                                + stage_wghts[l].gamma_3*0.0
>                                + stage_wghts[l].beta;
>         stage_wghts[l+1].sbeta = stage_wghts[l].ebeta;
>       }
>       stage_wghts[nstages-1].ebeta = 1.0;
>     }
176,186c731,744
<     // SSPRK (5,4): Gottlieb (2009) section 3.1; between eq 3.3 and 3.4
<     // Optimal (in error bounds) explicit five-stage, fourth-order SSPRK
<     // 3N method, but there is no 3S* formulation due to irregular sparsity
<     // of Shu-Osher form matrix, alpha.
<     nstages = 5;
<     // Because it is an SSP method, we can use the SSP coefficient c=1.508 to to trivially
<     // relate the CFL constraint to the RK1 CFL=1 (for first-order fluxes). There is no
<     // need to perform stability analysis from scratch (unlike e.g. the linear stability
<     // analysis for classical/non-SSP RK4 in Colella (2011)) However, PLM and PPM w/o the
<     // limiter engaged are unconditionally unstable under RK1 integration, so the SSP
<     // guarantees do not hold for the Athena++ spatial discretizations.
---
>     //! \note `integrator == "ssprk5_4"`
>     //! - SSPRK (5,4): Gottlieb (2009) section 3.1; between eq 3.3 and 3.4
>     //! - Optimal (in error bounds) explicit five-stage, fourth-order SSPRK
>     //!   3N method, but there is no 3S* formulation due to irregular sparsity
>     //!   of Shu-Osher form matrix, alpha.
>     //! - Because it is an SSP method, we can use the SSP coefficient c=1.508 to to
>     //!   trivially relate the CFL constraint to the RK1 CFL=1 (for first-order fluxes).
>     //! - There is no need to perform stability analysis from scratch
>     //!   (unlike e.g. the linear stability analysis for classical/non-SSP RK4 in
>     //!   Colella (2011)).
>     //! - However, PLM and PPM w/o the limiter engaged are unconditionally unstable
>     //!   under RK1 integration, so the SSP guarantees do not hold for
>     //!   the Athena++ spatial discretizations.
>     nstages_main = 5;
188,221c746,877
<     // u^(1)
<     stage_wghts[0].delta = 1.0; // u1 = u^n
<     stage_wghts[0].gamma_1 = 0.0;
<     stage_wghts[0].gamma_2 = 1.0;
<     stage_wghts[0].gamma_3 = 0.0;
<     stage_wghts[0].beta = 0.391752226571890;
<
<     // u^(2)
<     stage_wghts[1].delta = 0.0; // u1 = u^n
<     stage_wghts[1].gamma_1 = 0.555629506348765;
<     stage_wghts[1].gamma_2 = 0.444370493651235;
<     stage_wghts[1].gamma_3 = 0.0;
<     stage_wghts[1].beta = 0.368410593050371;
<
<     // u^(3)
<     stage_wghts[2].delta = 0.517231671970585; // u1 <- (u^n + d*u^(2))
<     stage_wghts[2].gamma_1 = 0.379898148511597;
<     stage_wghts[2].gamma_2 = 0.0;
<     stage_wghts[2].gamma_3 = 0.620101851488403; // u^(n) coeff =  u2
<     stage_wghts[2].beta = 0.251891774271694;
<
<     // u^(4)
<     stage_wghts[3].delta = 0.096059710526147; // u1 <- (u^n + d*u^(2) + d'*u^(3))
<     stage_wghts[3].gamma_1 = 0.821920045606868;
<     stage_wghts[3].gamma_2 = 0.0;
<     stage_wghts[3].gamma_3 = 0.178079954393132; // u^(n) coeff =  u2
<     stage_wghts[3].beta = 0.544974750228521;
<
<     // u^(n+1) partial expression
<     stage_wghts[4].delta = 0.0;
<     stage_wghts[4].gamma_1 = 0.386708617503268; // 1 ulp lower than Gottlieb u^(4) coeff
<     stage_wghts[4].gamma_2 = 1.0; // u1 <- (u^n + d*u^(2) + d'*u^(3))
<     stage_wghts[4].gamma_3 = 1.0; // partial sum from hardcoded extra stage=4
<     stage_wghts[4].beta = 0.226007483236906; // F(u^(4)) coeff.
---
>
>     if (ORBITAL_ADVECTION) {
>       if (pm->orbital_advection==1) { // first order splitting
>         nstages = nstages_main;
>         for (int l=0; l<nstages; l++) {
>           stage_wghts[l].main_stage = true;
>           if (l == nstages-1) { // last stage
>             stage_wghts[l].orbital_stage = true;
>           } else {
>             stage_wghts[l].orbital_stage = false;
>           }
>         }
>         stage_wghts[0].beta = 0.391752226571890;
>         stage_wghts[1].beta = 0.368410593050371;
>         stage_wghts[2].beta = 0.251891774271694;
>         stage_wghts[3].beta = 0.544974750228521;
>         stage_wghts[4].beta = 0.226007483236906; // F(u^(4)) coeff.
>       } else { // second order splitting
>         nstages = nstages_main+1;
>         for (int l=0; l<nstages; l++) {
>           if (l == 0) { // first stage
>             stage_wghts[l].main_stage = false;
>             stage_wghts[l].orbital_stage = true;
>           } else if (l == nstages-1) { // last stage
>             stage_wghts[l].main_stage = true;
>             stage_wghts[l].orbital_stage = true;
>           } else {
>             stage_wghts[l].main_stage = true;
>             stage_wghts[l].orbital_stage = false;
>           }
>         }
>         stage_wghts[0].beta = 0.0;
>         stage_wghts[1].beta = 0.391752226571890;
>         stage_wghts[2].beta = 0.368410593050371;
>         stage_wghts[3].beta = 0.251891774271694;
>         stage_wghts[4].beta = 0.544974750228521;
>         stage_wghts[5].beta = 0.226007483236906; // F(u^(4)) coeff.
>       }
>     } else { // w/o orbital advection
>       nstages = nstages_main;
>       for (int l=0; l<nstages; l++) {
>         stage_wghts[l].main_stage = true;
>         stage_wghts[l].orbital_stage = false;
>       }
>       stage_wghts[0].beta = 0.391752226571890;
>       stage_wghts[1].beta = 0.368410593050371;
>       stage_wghts[2].beta = 0.251891774271694;
>       stage_wghts[3].beta = 0.544974750228521;
>       stage_wghts[4].beta = 0.226007483236906; // F(u^(4)) coeff.
>     }
>
>     // set delta and gamma at each stage
>     int n_main = 0;
>     for (int n=0; n<nstages; n++) {
>       if (stage_wghts[n].main_stage) {
>         if (n_main == 0) {
>           stage_wghts[n].delta = 1.0; // u1 = u^n
>           stage_wghts[n].gamma_1 = 0.0;
>           stage_wghts[n].gamma_2 = 1.0;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 1) {
>           stage_wghts[n].delta = 0.0; // u1 = u^n
>           stage_wghts[n].gamma_1 = 0.555629506348765;
>           stage_wghts[n].gamma_2 = 0.444370493651235;
>           stage_wghts[n].gamma_3 = 0.0;
>           n_main++;
>         } else if (n_main == 2) {
>           stage_wghts[n].delta = 0.517231671970585; // u1 <- (u^n + d*u^(2))
>           stage_wghts[n].gamma_1 = 0.379898148511597;
>           stage_wghts[n].gamma_2 = 0.0;
>           stage_wghts[n].gamma_3 = 0.620101851488403; // u^(n) coeff =  u2
>           n_main++;
>         } else if (n_main == 3) {
>           stage_wghts[n].delta = 0.096059710526147; // u1 <- (u^n + d*u^(2) + d'*u^(3))
>           stage_wghts[n].gamma_1 = 0.821920045606868;
>           stage_wghts[n].gamma_2 = 0.0;
>           stage_wghts[n].gamma_3 = 0.178079954393132; // u^(n) coeff =  u2
>           n_main++;
>         } else if (n_main == 4) {
>           stage_wghts[n].delta = 0.0;
>           // 1 ulp lower than Gottlieb u^(4) coeff
>           stage_wghts[n].gamma_1 = 0.386708617503268;
>           // u1 <- (u^n + d*u^(2) + d'*u^(3))
>           stage_wghts[n].gamma_2 = 1.0;
>           // partial sum from hardcoded extra stage=4
>           stage_wghts[n].gamma_3 = 1.0;
>           n_main++;
>         }
>       }
>     }
>
>     // set sbeta & ebeta
>     if (ORBITAL_ADVECTION) {
>       if (pm->orbital_advection==1) { // first order splitting
>         for (int l=0; l<nstages; l++) {
>           if (l == nstages-1) { // last stage
>             stage_wghts[l].ebeta = 1.0;
>           } else {
>             stage_wghts[l].ebeta = 0.0;
>           }
>           stage_wghts[l].sbeta = 0.0;
>         }
>       } else { // second order splitting
>         for (int l=0; l<nstages; l++) {
>           if (l == 0) { // first stage
>             stage_wghts[l].sbeta = 0.0;
>           } else if (l == nstages-1) { // last stage
>             stage_wghts[l].sbeta = 0.5;
>             stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>             stage_wghts[l].ebeta = 1.0;
>           } else {
>             stage_wghts[l].sbeta = 0.5;
>             stage_wghts[l-1].ebeta = stage_wghts[l].sbeta;
>           }
>         }
>       }
>     } else { // w/o orbital advection ///
>       Real temp = 0.0;
>       Real temp_prev = 0.0;
>       stage_wghts[0].sbeta = 0.0;
>       for (int l=0; l<nstages-1; l++) {
>         temp_prev = temp;
>         temp = temp_prev + stage_wghts[l].delta*stage_wghts[l].sbeta;
>         stage_wghts[l].ebeta = stage_wghts[l].gamma_1*temp_prev
>                                + stage_wghts[l].gamma_2*temp
>                                + stage_wghts[l].gamma_3*0.0
>                                + stage_wghts[l].beta;
>         stage_wghts[l+1].sbeta = stage_wghts[l].ebeta;
>       }
>       stage_wghts[nstages-1].ebeta = 1.0;
>     }
254d909
<       AddTask(CALC_RADFLX,DIFFUSE_HYD);
264,266c919
<     AddTask(CALC_TURBFLX,CALC_HYDFLX);
<
<     if (pm->multilevel) { // SMR or AMR
---
>     if (pm->multilevel || SHEAR_PERIODIC) { // SMR or AMR or shear periodic
269,272c922,943
<       AddTask(INT_HYD,RECV_HYDFLX);
<       AddTask(SEND_TURBFLX,CALC_TURBFLX);
<       AddTask(RECV_TURBFLX,CALC_TURBFLX);
<       AddTask(INT_TURB,RECV_TURBFLX);
---
>       if (SHEAR_PERIODIC) {
>         AddTask(SEND_HYDFLXSH,RECV_HYDFLX);
>         AddTask(RECV_HYDFLXSH,(SEND_HYDFLX|RECV_HYDFLX));
>         AddTask(INT_HYD,RECV_HYDFLXSH);
>       } else {
>         AddTask(INT_HYD,RECV_HYDFLX);
>       }
>     } else {
>       AddTask(INT_HYD, CALC_HYDFLX);
>     }
>     if (NSCALARS > 0) {
>       AddTask(SRC_TERM,(INT_HYD|INT_SCLR));
>     } else {
>       AddTask(SRC_TERM,INT_HYD);
>     }
>     if (ORBITAL_ADVECTION) {
>       AddTask(SEND_HYDORB,SRC_TERM);
>       AddTask(RECV_HYDORB,NONE);
>       AddTask(CALC_HYDORB,(SEND_HYDORB|RECV_HYDORB));
>       AddTask(SEND_HYD,CALC_HYDORB);
>       AddTask(RECV_HYD,NONE);
>       AddTask(SETB_HYD,(RECV_HYD|CALC_HYDORB));
274,275c945,947
<       AddTask(INT_HYD, (CALC_HYDFLX|CALC_RADFLX));
<       AddTask(INT_TURB,CALC_TURBFLX);
---
>       AddTask(SEND_HYD,SRC_TERM);
>       AddTask(RECV_HYD,NONE);
>       AddTask(SETB_HYD,(RECV_HYD|SRC_TERM));
278,291c950
<     AddTask(SRCTERM_HYD,INT_HYD);
<     AddTask(INT_PART,SRCTERM_HYD);
<     AddTask(SEND_PART,INT_PART);
<     AddTask(RECV_PART,SEND_PART);
<     AddTask(ATTACH_PART,RECV_PART);
<     AddTask(PART2MESH,ATTACH_PART);
<     AddTask(UPDATE_HYD,INT_PART);
<     AddTask(INT_CHM,(UPDATE_HYD|PART2MESH));
<     AddTask(MESH2PART,INT_CHM);
<     // finish particles
<     AddTask(SEND_HYD,INT_CHM);
<     AddTask(RECV_HYD,NONE);
<     AddTask(SETB_HYD,(RECV_HYD|INT_CHM));
<     if (SHEARING_BOX) { // Shearingbox BC for Hydro
---
>     if (SHEAR_PERIODIC) {
293c952
<       AddTask(RECV_HYDSH,SETB_HYD);
---
>       AddTask(RECV_HYDSH,SEND_HYDSH);
297c956
<       if (pm->multilevel) {
---
>       if (pm->multilevel || SHEAR_PERIODIC) {
300c959,965
<         AddTask(INT_SCLR,RECV_SCLRFLX);
---
>         if (SHEAR_PERIODIC) {
>           AddTask(SEND_SCLRFLXSH,RECV_SCLRFLX);
>           AddTask(RECV_SCLRFLXSH,(SEND_SCLRFLX|RECV_SCLRFLX));
>           AddTask(INT_SCLR,RECV_SCLRFLXSH);
>         } else {
>           AddTask(INT_SCLR,RECV_SCLRFLX);
>         }
304,311c969,981
<       // there is no SRCTERM_SCLR task
<       AddTask(SEND_SCLR,INT_SCLR);
<       AddTask(RECV_SCLR,NONE);
<       AddTask(SETB_SCLR,(RECV_SCLR|INT_SCLR));
<       // if (SHEARING_BOX) {
<       //   AddTask(SEND_SCLRSH,SETB_SCLR);
<       //   AddTask(RECV_SCLRSH,SETB_SCLR);
<       // }
---
>       if (ORBITAL_ADVECTION) {
>         AddTask(SEND_SCLR,CALC_HYDORB);
>         AddTask(RECV_SCLR,NONE);
>         AddTask(SETB_SCLR,(RECV_SCLR|CALC_HYDORB));
>       } else {
>         AddTask(SEND_SCLR,SRC_TERM);
>         AddTask(RECV_SCLR,NONE);
>         AddTask(SETB_SCLR,(RECV_SCLR|SRC_TERM));
>       }
>       if (SHEAR_PERIODIC) {
>         AddTask(SEND_SCLRSH,SETB_SCLR);
>         AddTask(RECV_SCLRSH,SEND_SCLRSH);
>       }
314,317d983
<     AddTask(SEND_TURB,INT_TURB);
<     AddTask(RECV_TURB,NONE);
<     AddTask(SETB_TURB,(RECV_TURB|INT_TURB));
<
323c989
<       if (SHEARING_BOX) {// Shearingbox BC for EMF
---
>       if (SHEAR_PERIODIC) {
326,327c992
<         AddTask(RMAP_EMFSH,RECV_EMFSH);
<         AddTask(INT_FLD,RMAP_EMFSH);
---
>         AddTask(INT_FLD,RECV_EMFSH);
332,335c997,1009
<       AddTask(SEND_FLD,INT_FLD);
<       AddTask(RECV_FLD,NONE);
<       AddTask(SETB_FLD,(RECV_FLD|INT_FLD));
<       if (SHEARING_BOX) { // Shearingbox BC for Bfield
---
>       if (ORBITAL_ADVECTION) {
>         AddTask(SEND_FLDORB,INT_FLD);
>         AddTask(RECV_FLDORB,NONE);
>         AddTask(CALC_FLDORB,(SEND_FLDORB|RECV_FLDORB));
>         AddTask(SEND_FLD,CALC_FLDORB);
>         AddTask(RECV_FLD,NONE);
>         AddTask(SETB_FLD,(RECV_FLD|CALC_FLDORB));
>       } else {
>         AddTask(SEND_FLD,INT_FLD);
>         AddTask(RECV_FLD,NONE);
>         AddTask(SETB_FLD,(RECV_FLD|INT_FLD));
>       }
>       if (SHEAR_PERIODIC) {
337c1011
<         AddTask(RECV_FLDSH,SETB_FLD);
---
>         AddTask(RECV_FLDSH,SEND_FLDSH);
345,346c1019,1025
<         if (NSCALARS > 0) {
<           AddTask(PROLONG,(SEND_HYD|SETB_HYD|SEND_FLD|SETB_FLD|SEND_SCLR|SETB_SCLR));
---
>         if (SHEAR_PERIODIC) {
>           if (NSCALARS > 0) {
>             AddTask(PROLONG,(SEND_HYD|RECV_HYDSH|SEND_FLD|RECV_FLDSH
>                              |SEND_SCLR|RECV_SCLRSH));
>           } else {
>             AddTask(PROLONG,(SEND_HYD|RECV_HYDSH|SEND_FLD|RECV_FLDSH));
>           }
348c1027,1032
<           AddTask(PROLONG,(SEND_HYD|SETB_HYD|SEND_FLD|SETB_FLD));
---
>           if (NSCALARS > 0) {
>             AddTask(PROLONG,(SEND_HYD|SETB_HYD|SEND_FLD|SETB_FLD
>                              |SEND_SCLR|SETB_SCLR));
>           } else {
>             AddTask(PROLONG,(SEND_HYD|SETB_HYD|SEND_FLD|SETB_FLD));
>           }
352c1036
<         if (SHEARING_BOX) {
---
>         if (SHEAR_PERIODIC) {
354,355c1038
<             AddTask(CONS2PRIM,
<                     (SETB_HYD|SETB_FLD|SETB_SCLR|RECV_HYDSH|RECV_FLDSH|RMAP_EMFSH));
---
>             AddTask(CONS2PRIM,(RECV_HYDSH|RECV_FLDSH|RECV_SCLRSH));
357c1040
<             AddTask(CONS2PRIM,(SETB_HYD|SETB_FLD|RECV_HYDSH|RECV_FLDSH|RMAP_EMFSH));
---
>             AddTask(CONS2PRIM,(RECV_HYDSH|RECV_FLDSH));
361c1044
<             AddTask(CONS2PRIM,(SETB_TURB|SETB_HYD|SETB_FLD|SETB_SCLR));
---
>             AddTask(CONS2PRIM,(SETB_HYD|SETB_FLD|SETB_SCLR));
363c1046
<             AddTask(CONS2PRIM,(SETB_TURB|SETB_HYD|SETB_FLD));
---
>             AddTask(CONS2PRIM,(SETB_HYD|SETB_FLD));
370,371c1053,1058
<         if (NSCALARS > 0) {
<           AddTask(PROLONG,(SEND_HYD|SETB_HYD|SETB_SCLR|SEND_SCLR));
---
>         if (SHEAR_PERIODIC) {
>           if (NSCALARS > 0) {
>             AddTask(PROLONG,(SEND_HYD|RECV_HYDSH|SEND_SCLR|RECV_SCLRSH));
>           } else {
>             AddTask(PROLONG,(SEND_HYD|RECV_HYDSH));
>           }
373c1060,1064
<           AddTask(PROLONG,(SEND_HYD|SETB_HYD));
---
>           if (NSCALARS > 0) {
>             AddTask(PROLONG,(SEND_HYD|SETB_HYD|SEND_SCLR|SETB_SCLR));
>           } else {
>             AddTask(PROLONG,(SEND_HYD|SETB_HYD));
>           }
377c1068
<         if (SHEARING_BOX) {
---
>         if (SHEAR_PERIODIC) {
379c1070
<             AddTask(CONS2PRIM,(SETB_HYD|RECV_HYDSH|SETB_SCLR));  // RECV_SCLRSH
---
>             AddTask(CONS2PRIM,(RECV_HYDSH|RECV_SCLRSH));
381c1072
<             AddTask(CONS2PRIM,(SETB_HYD|RECV_HYDSH));
---
>             AddTask(CONS2PRIM,RECV_HYDSH);
385c1076
<             AddTask(CONS2PRIM,(SETB_TURB|SETB_HYD|SETB_SCLR));
---
>             AddTask(CONS2PRIM,(SETB_HYD|SETB_SCLR));
387c1078
<             AddTask(CONS2PRIM,(SETB_TURB|SETB_HYD));
---
>             AddTask(CONS2PRIM,SETB_HYD);
395,399c1086,1094
<     AddTask(USERWORK,PHY_BVAL);
<     AddTask(NEW_DT,USERWORK);
<     if (pm->adaptive) {
<       AddTask(FLAG_AMR,USERWORK);
<       AddTask(CLEAR_ALLBND,FLAG_AMR);
---
>     if (!STS_ENABLED || pm->sts_integrator == "rkl1") {
>       AddTask(USERWORK,PHY_BVAL);
>       AddTask(NEW_DT,USERWORK);
>       if (pm->adaptive) {
>         AddTask(FLAG_AMR,USERWORK);
>         AddTask(CLEAR_ALLBND,FLAG_AMR);
>       } else {
>         AddTask(CLEAR_ALLBND,NEW_DT);
>       }
401c1096
<       AddTask(CLEAR_ALLBND,NEW_DT);
---
>       AddTask(CLEAR_ALLBND,PHY_BVAL);
406,408c1101,1103
< //---------------------------------------------------------------------------------------
< //  Sets id and dependency for "ntask" member of task_list_ array, then iterates value of
< //  ntask.
---
> //----------------------------------------------------------------------------------------
> //!  Sets id and dependency for "ntask" member of task_list_ array, then iterates value of
> //!  ntask.
413,423c1108,1119
<   // TODO(felker): change naming convention of either/both of TASK_NAME and TaskFunc
<   // There are some issues with the current names:
<   // 1) VERB_OBJECT is confusing with ObjectVerb(). E.g. seeing SEND_HYD in the task list
<   // assembly would lead the user to believe the corresponding function is SendHydro(),
<   // when it is actually HydroSend()--- Probaby change function names to active voice
<   // VerbObject() since "HydroFluxCalculate()" doesn't sound quite right.
<
<   // Note, there are exceptions to the "verb+object" convention in some TASK_NAMES and
<   // TaskFunc, e.g. NEW_DT + NewBlockTimeStep() and AMR_FLAG + CheckRefinement(),
<   // SRCTERM_HYD and HydroSourceTerms(), USERWORK, PHY_BVAL, PROLONG, CONS2PRIM,
<   // ... Although, AMR_FLAG = "flag blocks for AMR" should be FLAG_AMR in VERB_OBJECT
---
>   //! \todo (felker):
>   //! - change naming convention of either/both of TASK_NAME and TaskFunc
>   //! - There are some issues with the current names:
>   //!   VERB_OBJECT is confusing with ObjectVerb(). E.g. seeing SEND_HYD in the task list
>   //!   assembly would lead the user to believe the corresponding function is
>   //!   SendHydro(), when it is actually HydroSend() ---
>   //!   Probaby change function names to active voice
>   //!   VerbObject() since "HydroFluxCalculate()" doesn't sound quite right.
>   //! - There are exceptions to the "verb+object" convention in some TASK_NAMES and
>   //!   TaskFunc, e.g. NEW_DT + NewBlockTimeStep() and AMR_FLAG + CheckRefinement(),
>   //!   SRC_TERM and SourceTerms(), USERWORK, PHY_BVAL, PROLONG, CONS2PRIM,
>   //!   ... Although, AMR_FLAG = "flag blocks for AMR" should be FLAG_AMR in VERB_OBJECT
440,444d1135
<   } else if (id == CALC_RADFLX) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::CalculateRadiationFlux);
<     task_list_[ntasks].lb_time = true;
475,485c1166
<   } else if (id == INT_CHM) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::IntegrateChemistry);
<     task_list_[ntasks].lb_time = true;
<   } else if (id == UPDATE_HYD) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::UpdateHydro);
<     task_list_[ntasks].lb_time = true;
<   } else if (id == SRCTERM_HYD) {
---
>   } else if (id == SRC_TERM) {
488c1169
<         (&TimeIntegratorTaskList::AddSourceTermsHydro);
---
>         (&TimeIntegratorTaskList::AddSourceTerms);
519a1201,1210
>   } else if (id == SEND_HYDFLXSH) {
>     task_list_[ntasks].TaskFunc=
>         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
>         (&TimeIntegratorTaskList::SendHydroFluxShear);
>     task_list_[ntasks].lb_time = true;
>   } else if (id == RECV_HYDFLXSH) {
>     task_list_[ntasks].TaskFunc=
>         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
>         (&TimeIntegratorTaskList::ReceiveHydroFluxShear);
>     task_list_[ntasks].lb_time = false;
550,554d1240
<   } else if (id == RMAP_EMFSH) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::RemapEMFShear);
<     task_list_[ntasks].lb_time = true;
630c1316
<   } else if (id == DIFFUSE_SCLR) {
---
>   } else if (id == SEND_SCLRSH) {
633c1319
<         (&TimeIntegratorTaskList::DiffuseScalars);
---
>         (&TimeIntegratorTaskList::SendScalarsShear);
635c1321
<   } else if (id == CALC_TURBFLX) {
---
>   } else if (id == RECV_SCLRSH) {
638,640c1324,1326
<         (&TimeIntegratorTaskList::CalculateTurbulenceFlux);
<     task_list_[ntasks].lb_time = true;
<   } else if (id == SEND_TURBFLX) {
---
>         (&TimeIntegratorTaskList::ReceiveScalarsShear);
>     task_list_[ntasks].lb_time = false;
>   } else if (id == SEND_SCLRFLXSH) {
643c1329
<         (&TimeIntegratorTaskList::SendTurbulenceFlux);
---
>         (&TimeIntegratorTaskList::SendScalarsFluxShear);
645c1331
<   } else if (id == RECV_TURBFLX) {
---
>   } else if (id == RECV_SCLRFLXSH) {
648c1334
<         (&TimeIntegratorTaskList::ReceiveTurbulenceFlux);
---
>         (&TimeIntegratorTaskList::ReceiveScalarsFluxShear);
650c1336
<   } else if (id == INT_TURB) {
---
>   } else if (id == DIFFUSE_SCLR) {
653c1339
<         (&TimeIntegratorTaskList::IntegrateTurbulence);
---
>         (&TimeIntegratorTaskList::DiffuseScalars);
655c1341
<   } else if (id == SEND_TURB) {
---
>   } else if (id == SEND_HYDORB) {
658c1344
<         (&TimeIntegratorTaskList::SendTurbulence);
---
>         (&TimeIntegratorTaskList::SendHydroOrbital);
660c1346
<   } else if (id == RECV_TURB) {
---
>   } else if (id == RECV_HYDORB) {
663c1349
<         (&TimeIntegratorTaskList::ReceiveTurbulence);
---
>         (&TimeIntegratorTaskList::ReceiveHydroOrbital);
665c1351
<   } else if (id == SETB_TURB) {
---
>   } else if (id == CALC_HYDORB) {
668c1354
<         (&TimeIntegratorTaskList::SetBoundariesTurbulence);
---
>         (&TimeIntegratorTaskList::CalculateHydroOrbital);
670,685c1356
<   } else if (id == MESH2PART) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::MeshToParticles);
<     task_list_[ntasks].lb_time = false;
<   } else if (id == INT_PART) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::IntegrateParticles);
<     task_list_[ntasks].lb_time = false;
<   } else if (id == SEND_PART) {
<     task_list_[ntasks].TaskFunc=
<         static_cast<TaskStatus (TaskList::*)(MeshBlock*,int)>
<         (&TimeIntegratorTaskList::SendParticles);
<     task_list_[ntasks].lb_time = false;
<   } else if (id == RECV_PART) {
---
>   } else if (id == SEND_FLDORB) {
688,690c1359,1361
<         (&TimeIntegratorTaskList::ReceiveParticles);
<     task_list_[ntasks].lb_time = false;
<   } else if (id == ATTACH_PART) {
---
>         (&TimeIntegratorTaskList::SendFieldOrbital);
>     task_list_[ntasks].lb_time = true;
>   } else if (id == RECV_FLDORB) {
693c1364
<         (&TimeIntegratorTaskList::AttachParticles);
---
>         (&TimeIntegratorTaskList::ReceiveFieldOrbital);
695c1366
<   } else if (id == PART2MESH) {
---
>   } else if (id == CALC_FLDORB) {
698,699c1369,1370
<         (&TimeIntegratorTaskList::ParticlesToMesh);
<     task_list_[ntasks].lb_time = false;
---
>         (&TimeIntegratorTaskList::CalculateFieldOrbital);
>     task_list_[ntasks].lb_time = true;
709a1381,1383
> //----------------------------------------------------------------------------------------
> //! \fn void TimeIntegratorTaskList::StartupTaskList(MeshBlock *pmb, int stage)
> //! \brief Initialize time abscissae
713,735d1386
<     // For each Meshblock, initialize time abscissae of each memory register pair (u,b)
<     // at stage=0 to correspond to the beginning of the interval [t^n, t^{n+1}]
<     pmb->stage_abscissae[0][0] = 0.0;
<     pmb->stage_abscissae[0][1] = 0.0; // u1 advances to u1 = 0*u1 + 1.0*u in stage=1
<     pmb->stage_abscissae[0][2] = 0.0; // u2 = u cached for all stages in 3S* methods
<
<     // Given overall timestep dt, compute the time abscissae for all registers, stages
<     for (int l=1; l<=nstages; l++) {
<       // Update the dt abscissae of each memory register to values at end of this stage
<       const IntegratorWeight w = stage_wghts[l-1];
<
<       // u1 = u1 + delta*u
<       pmb->stage_abscissae[l][1] = pmb->stage_abscissae[l-1][1]
<                                    + w.delta*pmb->stage_abscissae[l-1][0];
<       // u = gamma_1*u + gamma_2*u1 + gamma_3*u2 + beta*dt*F(u)
<       pmb->stage_abscissae[l][0] = w.gamma_1*pmb->stage_abscissae[l-1][0]
<                                    + w.gamma_2*pmb->stage_abscissae[l][1]
<                                    + w.gamma_3*pmb->stage_abscissae[l-1][2]
<                                    + w.beta*pmb->pmy_mesh->dt;
<       // u2 = u^n
<       pmb->stage_abscissae[l][2] = 0.0;
<     }
<
750c1401
<             << "integrator=" << integrator << " is currently incompatible with MHD"
---
>             << "integrator=" << integrator << " is currently incompatible with MHD."
761,764d1411
<
<     pmb->pturb->s1.ZeroClear();
<     if (integrator == "ssprk5_4")
<       pmb->pturb->s2 = pmb->pturb->s;
767,770c1414,1434
<   if (SHEARING_BOX) {
<     Real dt = (stage_wghts[(stage-1)].beta)*(pmb->pmy_mesh->dt);
<     Real time = pmb->pmy_mesh->time+dt;
<     pmb->pbval->ComputeShear(time);
---
>   if (SHEAR_PERIODIC) {
>     Real dt_fc   = pmb->pmy_mesh->dt*(stage_wghts[stage-1].sbeta);
>     Real dt_int  = pmb->pmy_mesh->dt*(stage_wghts[stage-1].ebeta);
>     Real time = pmb->pmy_mesh->time;
>     if (stage==1 ||
>         ((stage_wghts[stage-1].sbeta != stage_wghts[stage-2].sbeta)
>         || (stage_wghts[stage-1].ebeta != stage_wghts[stage-2].ebeta)))
>       pmb->pbval->ComputeShear(time+dt_fc, time+dt_int);
>   }
>
>   if (stage_wghts[stage-1].main_stage) {
>     pmb->pbval->StartReceivingSubset(BoundaryCommSubset::all, pmb->pbval->bvars_main_int);
>   } else {
>     pmb->pbval->StartReceivingSubset(BoundaryCommSubset::orbital,
>                                      pmb->pbval->bvars_main_int);
>   }
>   if (stage_wghts[stage-1].orbital_stage && pmb->porb->orbital_advection_active) {
>     Real dt = (stage_wghts[(stage-1)].ebeta-stage_wghts[(stage-1)].sbeta)
>               *pmb->pmy_mesh->dt;
>     pmb->porb->orb_bc->ComputeOrbit(dt);
>     pmb->porb->orb_bc->StartReceiving(BoundaryCommSubset::all);
772,773d1435
<   pmb->pbval->StartReceiving(BoundaryCommSubset::all);
<
778c1440
< // Functions to end MPI communication
---
> //! Functions to end MPI communication
781,788c1443,1451
<   pmb->pbval->ClearBoundary(BoundaryCommSubset::all);
<   // particle boundary at final stage
<   if (stage == nstages) {
<     Particles *ppart = pmb->ppart;
<     while (ppart != nullptr) {
<       ppart->ppb->ClearBoundary();
<       ppart = ppart->next;
<     }
---
>   if (stage_wghts[stage-1].main_stage) {
>     pmb->pbval->ClearBoundarySubset(BoundaryCommSubset::all,
>                                     pmb->pbval->bvars_main_int);
>   } else {
>     pmb->pbval->ClearBoundarySubset(BoundaryCommSubset::orbital,
>                                     pmb->pbval->bvars_main_int);
>   }
>   if (stage_wghts[stage-1].orbital_stage && pmb->porb->orbital_advection_active) {
>     pmb->porb->orb_bc->ClearBoundary(BoundaryCommSubset::all);
789a1453
>
794c1458
< // Functions to calculates fluxes
---
> // Functions to calculates Hydro fluxes
801,806c1465,1470
<     if ((stage == 1) && (integrator == "vl2")) {
<       phydro->CalculateFluxes(phydro->w,  pfield->b,  pfield->bcc, 1);
<       return TaskStatus::next;
<     } else {
<       phydro->CalculateFluxes(phydro->w,  pfield->b,  pfield->bcc, pmb->precon->xorder);
<       return TaskStatus::next;
---
>     if (stage_wghts[stage-1].main_stage) {
>       if ((integrator == "vl2") && (stage-stage_wghts[0].orbital_stage == 1)) {
>         phydro->CalculateFluxes(phydro->w,  pfield->b,  pfield->bcc, 1);
>       } else {
>         phydro->CalculateFluxes(phydro->w,  pfield->b,  pfield->bcc, pmb->precon->xorder);
>       }
807a1472
>     return TaskStatus::next;
811a1477,1478
> //----------------------------------------------------------------------------------------
> // Functions to calculates EMFs
815c1482,1484
<     pmb->pfield->ComputeCornerE(pmb->phydro->w,  pmb->pfield->bcc);
---
>     if (stage_wghts[stage-1].main_stage) {
>       pmb->pfield->ComputeCornerE(pmb->phydro->w,  pmb->pfield->bcc);
>     }
825,826c1494,1502
<   pmb->phydro->hbvar.SendFluxCorrection();
<   return TaskStatus::success;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->phydro->hbvar.SendFluxCorrection();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
828a1505,1506
> //----------------------------------------------------------------------------------------
> // Functions to communicate emf between MeshBlocks for flux correction with AMR
831,832c1509,1517
<   pmb->pfield->fbvar.SendFluxCorrection();
<   return TaskStatus::success;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->pfield->fbvar.SendFluxCorrection();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
839,842c1524,1535
<   if (pmb->phydro->hbvar.ReceiveFluxCorrection()) {
<     return TaskStatus::next;
<   } else {
<     return TaskStatus::fail;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->phydro->hbvar.ReceiveFluxCorrection()) {
>         return TaskStatus::next;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::next;
>     }
843a1537
>   return TaskStatus::fail;
845a1540,1542
> //----------------------------------------------------------------------------------------
> // Functions to receive emf between MeshBlocks
>
847,850c1544,1555
<   if (pmb->pfield->fbvar.ReceiveFluxCorrection()) {
<     return TaskStatus::next;
<   } else {
<     return TaskStatus::fail;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->pfield->fbvar.ReceiveFluxCorrection()) {
>         return TaskStatus::next;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::next;
>     }
851a1557
>   return TaskStatus::fail;
855c1561
< // Functions to integrate conserved variables
---
> // Functions to integrate Hydro variables
864,890c1570,1574
<     // This time-integrator-specific averaging operation logic is identical to FieldInt
<     Real ave_wghts[3];
<     ave_wghts[0] = 1.0;
<     ave_wghts[1] = stage_wghts[stage-1].delta;
<     ave_wghts[2] = 0.0;
<     pmb->WeightedAve(ph->u1, ph->u, ph->u2, ave_wghts);
<
<     ave_wghts[0] = stage_wghts[stage-1].gamma_1;
<     ave_wghts[1] = stage_wghts[stage-1].gamma_2;
<     ave_wghts[2] = stage_wghts[stage-1].gamma_3;
<     if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0)
<       ph->u.SwapAthenaArray(ph->u1);
<     else
<       pmb->WeightedAve(ph->u, ph->u1, ph->u2, ave_wghts);
<
<     const Real wght = stage_wghts[stage-1].beta*pmb->pmy_mesh->dt;
<     ph->du.ZeroClear();
<     ph->AddFluxDivergence(wght, ph->du);
<     // add coordinate (geometric) source terms
<     pmb->pcoord->AddCoordTermsDivergence(wght, ph->flux, ph->w, pf->bcc, ph->du);
<
<     // Hardcode an additional flux divergence weighted average for the penultimate
<     // stage of SSPRK(5,4) since it cannot be expressed in a 3S* framework
<     if (stage == 4 && integrator == "ssprk5_4") {
<       // From Gottlieb (2009), u^(n+1) partial calculation
<       ave_wghts[0] = -1.0; // -u^(n) coeff.
<       ave_wghts[1] = 0.0;
---
>     if (stage_wghts[stage-1].main_stage) {
>       // This time-integrator-specific averaging operation logic is identical to FieldInt
>       Real ave_wghts[5];
>       ave_wghts[0] = 1.0;
>       ave_wghts[1] = stage_wghts[stage-1].delta;
892,896c1576,1589
<       const Real beta = 0.063692468666290; // F(u^(3)) coeff.
<       const Real wght_ssp = beta*pmb->pmy_mesh->dt;
<       // writing out to u2 register
<       pmb->WeightedAve(ph->u2, ph->u1, ph->u2, ave_wghts);
<       ph->AddFluxDivergence(wght_ssp, ph->u2);
---
>       ave_wghts[3] = 0.0;
>       ave_wghts[4] = 0.0;
>       pmb->WeightedAve(ph->u1, ph->u, ph->u2, ph->u0, ph->fl_div, ave_wghts);
>
>       ave_wghts[0] = stage_wghts[stage-1].gamma_1;
>       ave_wghts[1] = stage_wghts[stage-1].gamma_2;
>       ave_wghts[2] = stage_wghts[stage-1].gamma_3;
>       if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0)
>         ph->u.SwapAthenaArray(ph->u1);
>       else
>         pmb->WeightedAve(ph->u, ph->u1, ph->u2, ph->u0, ph->fl_div, ave_wghts);
>
>       const Real wght = stage_wghts[stage-1].beta*pmb->pmy_mesh->dt;
>       ph->AddFluxDivergence(wght, ph->u);
898c1591,1607
<       pmb->pcoord->AddCoordTermsDivergence(wght_ssp, ph->flux, ph->w, pf->bcc, ph->u2);
---
>       pmb->pcoord->AddCoordTermsDivergence(wght, ph->flux, ph->w, pf->bcc, ph->u);
>
>       // Hardcode an additional flux divergence weighted average for the penultimate
>       // stage of SSPRK(5,4) since it cannot be expressed in a 3S* framework
>       if (stage == 4 && integrator == "ssprk5_4") {
>         // From Gottlieb (2009), u^(n+1) partial calculation
>         ave_wghts[0] = -1.0; // -u^(n) coeff.
>         ave_wghts[1] = 0.0;
>         ave_wghts[2] = 0.0;
>         const Real beta = 0.063692468666290; // F(u^(3)) coeff.
>         const Real wght_ssp = beta*pmb->pmy_mesh->dt;
>         // writing out to u2 register
>         pmb->WeightedAve(ph->u2, ph->u1, ph->u2, ph->u0, ph->fl_div, ave_wghts);
>         ph->AddFluxDivergence(wght_ssp, ph->u2);
>         // add coordinate (geometric) source terms
>         pmb->pcoord->AddCoordTermsDivergence(wght_ssp, ph->flux, ph->w, pf->bcc, ph->u2);
>       }
904a1614,1616
> //----------------------------------------------------------------------------------------
> // Functions to integrate Field variables
>
912,930c1624,1643
<     // This time-integrator-specific averaging operation logic is identical to HydroInt
<     Real ave_wghts[3];
<     ave_wghts[0] = 1.0;
<     ave_wghts[1] = stage_wghts[stage-1].delta;
<     ave_wghts[2] = 0.0;
<     pmb->WeightedAve(pf->b1, pf->b, pf->b2, ave_wghts);
<
<     ave_wghts[0] = stage_wghts[stage-1].gamma_1;
<     ave_wghts[1] = stage_wghts[stage-1].gamma_2;
<     ave_wghts[2] = stage_wghts[stage-1].gamma_3;
<     if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0) {
<       pf->b.x1f.SwapAthenaArray(pf->b1.x1f);
<       pf->b.x2f.SwapAthenaArray(pf->b1.x2f);
<       pf->b.x3f.SwapAthenaArray(pf->b1.x3f);
<     } else {
<       pmb->WeightedAve(pf->b, pf->b1, pf->b2, ave_wghts);
<     }
<
<     pf->CT(stage_wghts[stage-1].beta*pmb->pmy_mesh->dt, pf->b);
---
>     if (stage_wghts[stage-1].main_stage) {
>       // This time-integrator-specific averaging operation logic is identical to HydroInt
>       Real ave_wghts[5];
>       ave_wghts[0] = 1.0;
>       ave_wghts[1] = stage_wghts[stage-1].delta;
>       ave_wghts[2] = 0.0;
>       ave_wghts[3] = 0.0;
>       ave_wghts[4] = 0.0;
>       pmb->WeightedAve(pf->b1, pf->b, pf->b2, pf->b0, pf->ct_update, ave_wghts);
>
>       ave_wghts[0] = stage_wghts[stage-1].gamma_1;
>       ave_wghts[1] = stage_wghts[stage-1].gamma_2;
>       ave_wghts[2] = stage_wghts[stage-1].gamma_3;
>       if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0) {
>         pf->b.x1f.SwapAthenaArray(pf->b1.x1f);
>         pf->b.x2f.SwapAthenaArray(pf->b1.x2f);
>         pf->b.x3f.SwapAthenaArray(pf->b1.x3f);
>       } else {
>         pmb->WeightedAve(pf->b, pf->b1, pf->b2, pf->b0, pf->ct_update, ave_wghts);
>       }
931a1645,1646
>       pf->CT(stage_wghts[stage-1].beta*pmb->pmy_mesh->dt, pf->b);
>     }
934d1648
<
939c1653
< // Functions to add source terms
---
> //! Functions to add source terms
941c1655
< TaskStatus TimeIntegratorTaskList::AddSourceTermsHydro(MeshBlock *pmb, int stage) {
---
> TaskStatus TimeIntegratorTaskList::AddSourceTerms(MeshBlock *pmb, int stage) {
943a1658
>   PassiveScalars *ps = pmb->pscalars;
950,958c1665,1675
<     // Time at beginning of stage for u()
<     Real t_start_stage = pmb->pmy_mesh->time + pmb->stage_abscissae[stage-1][0];
<     // Scaled coefficient for RHS update
<     Real dt = (stage_wghts[(stage-1)].beta)*(pmb->pmy_mesh->dt);
<     // Evaluate the time-dependent source terms at the time at the beginning of the stage
<     ph->hsrc.AddHydroSourceTerms(t_start_stage, dt, ph->flux, ph->w, pf->bcc, ph->du);
<     pmb->pphy->ApplyPhysicsPackages(ph->du, ph->w, pmb->pmy_mesh->time, pmb->pmy_mesh->dt);
<   } else {
<     return TaskStatus::fail;
---
>     if (stage_wghts[stage-1].main_stage) {
>       // Time at beginning of stage for u()
>       Real t_start_stage = pmb->pmy_mesh->time
>                            + stage_wghts[(stage-1)].sbeta*pmb->pmy_mesh->dt;
>       // Scaled coefficient for RHS update
>       Real dt = (stage_wghts[(stage-1)].beta)*(pmb->pmy_mesh->dt);
>       // Evaluate the source terms at the time at the beginning of the stage
>       ph->hsrc.AddSourceTerms(t_start_stage, dt, ph->flux, ph->w, ps->r, pf->bcc,
>                                    ph->u, ps->s);
>     }
>     return TaskStatus::next;
960c1677
<   return TaskStatus::next;
---
>   return TaskStatus::fail;
964,965c1681,1682
< // Functions to calculate hydro diffusion fluxes (stored in HydroDiffusion::visflx[],
< // cndflx[], added at the end of Hydro::CalculateFluxes()
---
> //! Functions to calculate hydro diffusion fluxes (stored in HydroDiffusion::visflx[],
> //! cndflx[], added at the end of Hydro::CalculateFluxes()
968a1686
>   Field *pf = pmb->pfield;
975,977c1693,1704
<     ph->hdif.CalcDiffusionFlux(ph->w, ph->u, ph->flux);
<   } else {
<     return TaskStatus::fail;
---
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       // if using orbital advection, put modified conservative into the function
>       if (pmb->porb->orbital_advection_defined) {
>         pmb->porb->ConvertOrbitalSystem(ph->w, ph->u, OrbitalTransform::prim);
>         ph->hdif.CalcDiffusionFlux(ph->w, pmb->porb->w_orb, pf->bcc);
>       } else {
>         ph->hdif.CalcDiffusionFlux(ph->w, ph->w, pf->bcc);
>       }
>     }
>     return TaskStatus::next;
979c1706
<   return TaskStatus::next;
---
>   return TaskStatus::fail;
983c1710
< // Functions to calculate diffusion EMF
---
> //! Functions to calculate diffusion EMF
992,997c1719,1727
<     // TODO(pdmullen): DiffuseField is also called in SuperTimeStepTaskLsit. It must skip
<     // Hall effect (once implemented) diffusion process in STS and always calculate those
<     // terms in the main integrator.
<     pf->fdif.CalcDiffusionEMF(pf->b, pf->bcc, pf->e);
<   } else {
<     return TaskStatus::fail;
---
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       // TODO(pdmullen): DiffuseField is also called in SuperTimeStepTaskLsit.
>       // It must skip Hall effect (once implemented) diffusion process in STS
>       // and always calculate those terms in the main integrator.
>       pf->fdif.CalcDiffusionEMF(pf->b, pf->bcc, pf->e);
>     }
>     return TaskStatus::next;
999c1729
<   return TaskStatus::next;
---
>   return TaskStatus::fail;
1003c1733
< // Functions to communicate conserved variables between MeshBlocks
---
> //! Functions to communicate Hydro variables between MeshBlocks
1016a1747,1748
> //----------------------------------------------------------------------------------------
> //! Functions to communicate Field variables between MeshBlocks
1028c1760
< // Functions to receive conserved variables between MeshBlocks
---
> //! Functions to receive Hydro variables between MeshBlocks
1043a1776,1777
> //----------------------------------------------------------------------------------------
> //! Functions to receive Field variables between MeshBlocks
1058a1793,1794
> //----------------------------------------------------------------------------------------
> //! Functions to set Hydro boundaries
1068a1805,1806
> //----------------------------------------------------------------------------------------
> //! Functions to set Field boundaries
1077a1816,1817
> //----------------------------------------------------------------------------------------
> //! Functions to communicate Hydro variables between MeshBlocks with shear
1087a1828,1829
> //----------------------------------------------------------------------------------------
> //! Functions to communicate Hydro variables between MeshBlocks with shear
1097a1840
>     pmb->phydro->hbvar.SetShearingBoxBoundaryBuffers();
1103a1847,1880
> //----------------------------------------------------------------------------------------
> //! Functions to communicate Field variables between MeshBlocks with shear
>
> TaskStatus TimeIntegratorTaskList::SendHydroFluxShear(MeshBlock *pmb, int stage) {
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->phydro->hbvar.SendFluxShearingBoxBoundaryBuffers();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::ReceiveHydroFluxShear(MeshBlock *pmb, int stage) {
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->phydro->hbvar.ReceiveFluxShearingBoxBoundaryBuffers()) {
>         pmb->phydro->hbvar.SetFluxShearingBoxBoundaryBuffers();
>         return TaskStatus::success;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::success;
>     }
>   }
>   return TaskStatus::fail;
> }
>
1113a1891,1892
> //----------------------------------------------------------------------------------------
> //! Functions to communicate Field variables between MeshBlocks with shear
1123a1903
>     pmb->pfield->fbvar.SetShearingBoxBoundaryBuffers();
1129a1910,1911
> //----------------------------------------------------------------------------------------
> //! Functions to communicate EMFs between MeshBlocks with shear
1132,1133c1914,1922
<   pmb->pfield->fbvar.SendEMFShearingBoxBoundaryCorrection();
<   return TaskStatus::success;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->pfield->fbvar.SendEMFShearingBoxBoundaryCorrection();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
1135a1925,1926
> //----------------------------------------------------------------------------------------
> //! Functions to communicate EMFs between MeshBlocks with shear
1138,1141c1929,1941
<   if (pmb->pfield->fbvar.ReceiveEMFShearingBoxBoundaryCorrection()) {
<     return TaskStatus::next;
<   } else {
<     return TaskStatus::fail;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->pfield->fbvar.ReceiveEMFShearingBoxBoundaryCorrection()) {
>         pmb->pfield->fbvar.SetEMFShearingBoxBoundaryCorrection();
>         return TaskStatus::success;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::success;
>     }
1146,1151d1945
<
< TaskStatus TimeIntegratorTaskList::RemapEMFShear(MeshBlock *pmb, int stage) {
<   pmb->pfield->fbvar.RemapEMFShearingBoxBoundary();
<   return TaskStatus::success;
< }
<
1160c1954,1955
<     Real t_end_stage = pmb->pmy_mesh->time + pmb->stage_abscissae[stage][0];
---
>     Real t_end_stage = pmb->pmy_mesh->time
>                        + stage_wghts[(stage-1)].ebeta*pmb->pmy_mesh->dt;
1163,1165c1958,1959
<     pbval->ProlongateBoundaries(t_end_stage, dt);
<   } else {
<     return TaskStatus::fail;
---
>     pbval->ProlongateBoundaries(t_end_stage, dt, pmb->pbval->bvars_main_int);
>     return TaskStatus::success;
1167,1168c1961
<
<   return TaskStatus::success;
---
>   return TaskStatus::fail;
1176d1968
<   TurbulenceModel *pturb = pmb->pturb;
1197,1198c1989,1991
<     pmb->pturb->ConservedToPrimitive(pturb->s, ph->w, pturb->r,
<                                     pmb->pcoord, il, iu, jl, ju, kl, ku);
---
>     if (pmb->porb->orbital_advection_defined) {
>       pmb->porb->ResetOrbitalSystemConversionFlag();
>     }
1201,1202c1994
<       pmb->peos->PassiveScalarConservedToPrimitive(ps->s, ph->w1, // ph->u, (updated rho)
<                                                    ps->r, ps->r,
---
>       pmb->peos->PassiveScalarConservedToPrimitive(ps->s, ph->u, ps->r, ps->r,
1215a2008,2024
>       // Apply physical boundaries prior to 4th order W(U)
>       // Time at the end of stage for (u, b) register pair
>       Real t_end_stage = pmb->pmy_mesh->time
>                          + stage_wghts[(stage-1)].ebeta*pmb->pmy_mesh->dt;
>       // Scaled coefficient for RHS time-advance within stage
>       Real dt = (stage_wghts[(stage-1)].beta)*(pmb->pmy_mesh->dt);
>       // Swap Hydro and (possibly) passive scalar quantities in BoundaryVariable interface
>       // from conserved to primitive formulations:
>       ph->hbvar.SwapHydroQuantity(ph->w1, HydroBoundaryQuantity::prim);
>       if (NSCALARS > 0) {
>         ps->sbvar.var_cc = &(ps->r);
>         if (pmb->pmy_mesh->multilevel) {
>           ps->sbvar.coarse_buf = &(ps->coarse_r_);
>         }
>       }
>       pbval->ApplyPhysicalBoundaries(t_end_stage, dt, pmb->pbval->bvars_main_int);
>       // Perform 4th order W(U)
1228,1229c2037
<   } else {
<     return TaskStatus::fail;
---
>     return TaskStatus::success;
1231,1232c2039
<
<   return TaskStatus::success;
---
>   return TaskStatus::fail;
1239d2045
<   TurbulenceModel *pturb = pmb->pturb;
1244c2050,2051
<     Real t_end_stage = pmb->pmy_mesh->time + pmb->stage_abscissae[stage][0];
---
>     Real t_end_stage = pmb->pmy_mesh->time
>                        + stage_wghts[(stage-1)].ebeta*pmb->pmy_mesh->dt;
1250c2057
<     if (NSCALARS > 0)
---
>     if (NSCALARS > 0) {
1252,1255c2059,2064
<     pbval->ApplyPhysicalBoundaries(t_end_stage, dt);
<     pturb->applyBoundaryCondition(pturb->r, pturb->s, ph->w, pmb->pcoord);
<   } else {
<     return TaskStatus::fail;
---
>       if (pmb->pmy_mesh->multilevel) {
>         ps->sbvar.coarse_buf = &(ps->coarse_r_);
>       }
>     }
>     pbval->ApplyPhysicalBoundaries(t_end_stage, dt, pmb->pbval->bvars_main_int);
>     return TaskStatus::success;
1257,1258c2066
<
<   return TaskStatus::success;
---
>   return TaskStatus::fail;
1265,1270d2072
<   Diagnostics *p = pmb->pdiag->next;
<   while (p != nullptr) {
<     p->Progress(pmb->phydro->w);
<     p = p->next;
<   }
<
1295,1300c2097,2102
<     if ((stage == 1) && (integrator == "vl2")) {
<       ps->CalculateFluxes(ps->r, 1);
<       return TaskStatus::next;
<     } else {
<       ps->CalculateFluxes(ps->r, pmb->precon->xorder);
<       return TaskStatus::next;
---
>     if (stage_wghts[stage-1].main_stage) {
>       if ((integrator == "vl2") && (stage-stage_wghts[0].orbital_stage == 1)) {
>         ps->CalculateFluxes(ps->r, 1);
>       } else {
>         ps->CalculateFluxes(ps->r, pmb->precon->xorder);
>       }
1301a2104
>     return TaskStatus::next;
1308,1309c2111,2119
<   pmb->pscalars->sbvar.SendFluxCorrection();
<   return TaskStatus::success;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->pscalars->sbvar.SendFluxCorrection();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
1314,1317c2124,2135
<   if (pmb->pscalars->sbvar.ReceiveFluxCorrection()) {
<     return TaskStatus::next;
<   } else {
<     return TaskStatus::fail;
---
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->pscalars->sbvar.ReceiveFluxCorrection()) {
>         return TaskStatus::next;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::next;
>     }
1318a2137
>   return TaskStatus::fail;
1323a2143
>
1325,1349c2145,2150
<     // This time-integrator-specific averaging operation logic is identical to
<     // IntegrateHydro, IntegrateField
<     Real ave_wghts[3];
<     ave_wghts[0] = 1.0;
<     ave_wghts[1] = stage_wghts[stage-1].delta;
<     ave_wghts[2] = 0.0;
<     pmb->WeightedAve(ps->s1, ps->s, ps->s2, ave_wghts);
<
<     ave_wghts[0] = stage_wghts[stage-1].gamma_1;
<     ave_wghts[1] = stage_wghts[stage-1].gamma_2;
<     ave_wghts[2] = stage_wghts[stage-1].gamma_3;
<     if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0)
<       ps->s.SwapAthenaArray(ps->s1);
<     else
<       pmb->WeightedAve(ps->s, ps->s1, ps->s2, ave_wghts);
<
<     const Real wght = stage_wghts[stage-1].beta*pmb->pmy_mesh->dt;
<     ps->AddFluxDivergence(wght, ps->s);
<
<     // Hardcode an additional flux divergence weighted average for the penultimate
<     // stage of SSPRK(5,4) since it cannot be expressed in a 3S* framework
<     if (stage == 4 && integrator == "ssprk5_4") {
<       // From Gottlieb (2009), u^(n+1) partial calculation
<       ave_wghts[0] = -1.0; // -u^(n) coeff.
<       ave_wghts[1] = 0.0;
---
>     if (stage_wghts[stage-1].main_stage) {
>       // This time-integrator-specific averaging operation logic is identical to
>       // IntegrateHydro, IntegrateField
>       Real ave_wghts[5];
>       ave_wghts[0] = 1.0;
>       ave_wghts[1] = stage_wghts[stage-1].delta;
1351,1355c2152,2179
<       const Real beta = 0.063692468666290; // F(u^(3)) coeff.
<       const Real wght_ssp = beta*pmb->pmy_mesh->dt;
<       // writing out to s2 register
<       pmb->WeightedAve(ps->s2, ps->s1, ps->s2, ave_wghts);
<       ps->AddFluxDivergence(wght_ssp, ps->s2);
---
>       ave_wghts[3] = 0.0;
>       ave_wghts[4] = 0.0;
>       pmb->WeightedAve(ps->s1, ps->s, ps->s2, ps->s0, ps->s_fl_div, ave_wghts);
>
>       ave_wghts[0] = stage_wghts[stage-1].gamma_1;
>       ave_wghts[1] = stage_wghts[stage-1].gamma_2;
>       ave_wghts[2] = stage_wghts[stage-1].gamma_3;
>       if (ave_wghts[0] == 0.0 && ave_wghts[1] == 1.0 && ave_wghts[2] == 0.0)
>         ps->s.SwapAthenaArray(ps->s1);
>       else
>         pmb->WeightedAve(ps->s, ps->s1, ps->s2, ps->s0, ps->s_fl_div, ave_wghts);
>
>       const Real wght = stage_wghts[stage-1].beta*pmb->pmy_mesh->dt;
>       ps->AddFluxDivergence(wght, ps->s);
>
>       // Hardcode an additional flux divergence weighted average for the penultimate
>       // stage of SSPRK(5,4) since it cannot be expressed in a 3S* framework
>       if (stage == 4 && integrator == "ssprk5_4") {
>         // From Gottlieb (2009), u^(n+1) partial calculation
>         ave_wghts[0] = -1.0; // -u^(n) coeff.
>         ave_wghts[1] = 0.0;
>         ave_wghts[2] = 0.0;
>         const Real beta = 0.063692468666290; // F(u^(3)) coeff.
>         const Real wght_ssp = beta*pmb->pmy_mesh->dt;
>         // writing out to s2 register
>         pmb->WeightedAve(ps->s2, ps->s1, ps->s2, ps->s0, ps->s_fl_div, ave_wghts);
>         ps->AddFluxDivergence(wght_ssp, ps->s2);
>       }
1367a2192,2194
>     if (pmb->pmy_mesh->multilevel) {
>       pmb->pscalars->sbvar.coarse_buf = &(pmb->pscalars->coarse_s_);
>     }
1395a2223,2225
>     if (pmb->pmy_mesh->multilevel) {
>       pmb->pscalars->sbvar.coarse_buf = &(pmb->pscalars->coarse_s_);
>     }
1411,1418c2241,2279
<     // TODO(felker): adapted directly from HydroDiffusion::ClearFlux. Deduplicate
<     ps->diffusion_flx[X1DIR].ZeroClear();
<     ps->diffusion_flx[X2DIR].ZeroClear();
<     ps->diffusion_flx[X3DIR].ZeroClear();
<
<     // unlike HydroDiffusion, only 1x passive scalar diffusive process is allowed, so
<     // there is no need for counterpart to wrapper fn HydroDiffusion::CalcDiffusionFlux
<     ps->DiffusiveFluxIso(ps->r, ph->w, ps->diffusion_flx);
---
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       // TODO(felker): adapted directly from HydroDiffusion::ClearFlux. Deduplicate
>       ps->diffusion_flx[X1DIR].ZeroClear();
>       ps->diffusion_flx[X2DIR].ZeroClear();
>       ps->diffusion_flx[X3DIR].ZeroClear();
>
>       // unlike HydroDiffusion, only 1x passive scalar diffusive process is allowed, so
>       // there is no need for counterpart to wrapper fn HydroDiffusion::CalcDiffusionFlux
>       ps->DiffusiveFluxIso(ps->r, ph->w, ps->diffusion_flx);
>     }
>     return TaskStatus::next;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::SendScalarsShear(MeshBlock *pmb, int stage) {
>   if (stage <= nstages) {
>     pmb->pscalars->sbvar.SendShearingBoxBoundaryBuffers();
>   } else {
>     return TaskStatus::fail;
>   }
>   return TaskStatus::success;
> }
>
>
> TaskStatus TimeIntegratorTaskList::ReceiveScalarsShear(MeshBlock *pmb, int stage) {
>   bool ret;
>   ret = false;
>   if (stage <= nstages) {
>     ret = pmb->pscalars->sbvar.ReceiveShearingBoxBoundaryBuffers();
>   } else {
>     return TaskStatus::fail;
>   }
>   if (ret) {
>     pmb->pscalars->sbvar.SetShearingBoxBoundaryBuffers();
>     return TaskStatus::success;
1422c2283,2406
<   return TaskStatus::next;
---
> }
>
>
> TaskStatus TimeIntegratorTaskList::SendScalarsFluxShear(MeshBlock *pmb, int stage) {
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       pmb->pscalars->sbvar.SendFluxShearingBoxBoundaryBuffers();
>     }
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::ReceiveScalarsFluxShear(MeshBlock *pmb, int stage) {
>   if (stage <= nstages) {
>     if (stage_wghts[stage-1].main_stage ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_before ||
>         pmb->pmy_mesh->sts_loc == TaskType::op_split_after) {
>       if (pmb->pscalars->sbvar.ReceiveFluxShearingBoxBoundaryBuffers()) {
>         pmb->pscalars->sbvar.SetFluxShearingBoxBoundaryBuffers();
>         return TaskStatus::success;
>       } else {
>         return TaskStatus::fail;
>       }
>     } else {
>       return TaskStatus::success;
>     }
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::SendHydroOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     if (!porb->orbital_advection_active) return TaskStatus::success;
>     Hydro *ph = pmb->phydro;
>     PassiveScalars *ps = pmb->pscalars;
>     porb->SetOrbitalAdvectionCC(ph->u, ps->s);
>     porb->orb_bc->SendBoundaryBuffersCC();
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::SendFieldOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     if (!porb->orbital_advection_active) return TaskStatus::success;
>     Field *pf = pmb->pfield;
>     porb->SetOrbitalAdvectionFC(pf->b);
>     porb->orb_bc->SendBoundaryBuffersFC();
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::ReceiveHydroOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     if (!porb->orbital_advection_active) return TaskStatus::success;
>     if (porb->orb_bc->ReceiveBoundaryBuffersCC()) {
>       return TaskStatus::success;
>     }
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::ReceiveFieldOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     if (!porb->orbital_advection_active) return TaskStatus::success;
>     if (porb->orb_bc->ReceiveBoundaryBuffersFC()) {
>       return TaskStatus::success;
>     }
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::CalculateHydroOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     Hydro *ph = pmb->phydro;
>     PassiveScalars *ps = pmb->pscalars;
>     Real dt = pmb->pmy_mesh->dt
>               *(stage_wghts[(stage-1)].ebeta-stage_wghts[(stage-1)].sbeta);
>     porb->CalculateOrbitalAdvectionCC(dt, ph->u, ps->s);
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
> }
>
>
> TaskStatus TimeIntegratorTaskList::CalculateFieldOrbital(MeshBlock *pmb, int stage) {
>   if (!stage_wghts[stage-1].orbital_stage) {
>     return TaskStatus::success;
>   } else {
>     OrbitalAdvection *porb = pmb->porb;
>     if (!porb->orbital_advection_active) return TaskStatus::success;
>     Field *pf = pmb->pfield;
>     Real dt = pmb->pmy_mesh->dt
>               *(stage_wghts[(stage-1)].ebeta-stage_wghts[(stage-1)].sbeta);
>     porb->CalculateOrbitalAdvectionFC(dt, pf->e);
>     pf->CT(1.0, pf->b);
>     return TaskStatus::success;
>   }
>   return TaskStatus::fail;
